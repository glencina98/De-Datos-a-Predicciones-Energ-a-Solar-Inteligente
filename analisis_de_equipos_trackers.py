# -*- coding: utf-8 -*-
"""Analisis de Equipos Trackers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VZeYmpRgcY8OoNUh7tgrx4foKKqNanvX
"""

!pip install pvlib pandas matplotlib

# ===============================================================
# CÁLCULO DE POSICIÓN DE TRACKER A UN EJE (pvlib)
# ===============================================================

# Requisitos:
# pip install pvlib pandas matplotlib

import pandas as pd
import pvlib
from pvlib.location import Location
from pvlib import tracking, irradiance
import matplotlib.pyplot as plt

# --- COORDENADAS Y CONFIGURACIÓN ---
lat, lon, alt = -25.0728, -67.7800, 3700   # San Antonio de los Cobres, Salta
tz = 'America/Argentina/Salta'

# --- PERÍODO: septiembre, de 08:00 a 19:00 cada 5 min ---
start = '2025-09-01 08:00'
end   = '2025-09-30 19:00'
freq  = '5min'

# --- PARÁMETROS DEL TRACKER ---
axis_tilt = 0.0              # eje horizontal (deg)
axis_azimuth = 4           # eje orientado Norte–Sur (0 = norte, 90 = este)
max_angle = 60.0             # límite de giro ±60°
backtrack = False              # backtracking activado
gcr = 0.475                    # relación cobertura del suelo (typ 0.2–0.4)

# ===============================================================
# 1️⃣ GENERAR FECHAS Y POSICIÓN SOLAR
# ===============================================================

times = pd.date_range(start=start, end=end, freq=freq, tz=tz)
site = Location(latitude=lat, longitude=lon, altitude=alt, tz=tz)
solpos = site.get_solarposition(times)

# ===============================================================
# 2️⃣ CALCULAR POSICIÓN DEL TRACKER
# ===============================================================

trk = tracking.singleaxis(
    apparent_zenith=solpos['apparent_zenith'],
    apparent_azimuth=solpos['azimuth'],
    axis_tilt=axis_tilt,
    axis_azimuth=axis_azimuth,
    max_angle=max_angle,
    backtrack=backtrack,
    gcr=gcr
)

# ===============================================================
# 3️⃣ CALCULAR ÁNGULO DE INCIDENCIA (opcional)
# ===============================================================

trk['aoi'] = irradiance.aoi(
    surface_tilt=trk['surface_tilt'],
    surface_azimuth=trk['surface_azimuth'],
    solar_zenith=solpos['apparent_zenith'],
    solar_azimuth=solpos['azimuth']
)

# ===============================================================
#  Ajustes de variables
# ===============================================================

# 1️⃣ Redefinir que horizontal = 90°
trk['tracker_theta_custom'] = trk['tracker_theta'] + 90

# 2️⃣ Cuando el Sol está por debajo del horizonte → dormir en 120°
# (podés cambiar 120 por otro valor si querés otra inclinación)
trk.loc[solpos['apparent_zenith'] > 90, 'tracker_theta_custom'] = 120

trk = trk.between_time('08:00', '19:00')
#cambiar nombre a columna

# ===============================================================
# 4️⃣ MOSTRAR RESULTADOS Y GUARDAR
# ===============================================================

print(trk[['tracker_theta','surface_tilt','surface_azimuth','aoi']].head())


# Guardar en Excel
excel_path = 'posicion_tracker_salta_sep.xlsx'

# Eliminamos el timezone para evitar errores en Excel
trk_copy = trk.copy()
trk_copy.index = trk_copy.index.tz_localize(None)

trk_copy.to_excel(excel_path, index=True)
print(f"✅ Archivo Excel guardado correctamente en: {excel_path}")
# ===============================================================
# 5️⃣ GRÁFICO DEL ÁNGULO DE TRACKER
# ===============================================================

plt.figure(figsize=(10,4))
plt.plot(trk.index, trk['tracker_theta'], label='Ángulo del tracker (°)')
plt.title('Posición del tracker - San Antonio de los Cobres - Septiembre')
plt.xlabel('Hora local')
plt.ylabel('Ángulo del tracker (°)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

trk.info()

trk_copy['TIME'] = trk_copy.index

import gdown
# ID del archivo
file_id = '1pjRIVE3y0o8D9-ZDG9Im38AkFRlCjiVZ'

# Construir la URL de descarga
url = f'https://drive.google.com/uc?id={file_id}'

# Ruta donde se guardará el archivo
output = '/content/Datos_DATOS_NCU.xlsx'

# Descargar el archivo
gdown.download(url, output, quiet=False)

# Leer el archivo Excel
df_ncu = pd.read_excel('/content/Datos_DATOS_NCU.xlsx')

# Ver las primeras filas
df_ncu.head()

# Redondear al hora más cercana
df_ncu.info()

df_ncu['t_stamp'] = pd.to_datetime(df_ncu['t_stamp'])

df_ncu= df_ncu.rename(columns={'t_stamp': 'TIME'})

import datetime
# Asegurarse que TIME sea datetime completo (fecha + hora)
df_ncu['TIME'] = pd.to_datetime(df_ncu['TIME'])

# Filtrar solo entre 08:00 y 19:00 (hora completa)

# Definir rango de fechas (ej: todo septiembre 2025)
fecha_inicio = '2025-09-01'
fecha_fin    = '2025-09-30'



# Redondear hacia abajo al múltiplo de 5 minutos
df_ncu['TIME_5MIN'] = df_ncu['TIME'].dt.floor('5min')

# Filtrar por fecha y hora
df_filtrado = df_ncu[
    (df_ncu['TIME'].dt.date >= pd.to_datetime(fecha_inicio).date()) &
    (df_ncu['TIME'].dt.date <= pd.to_datetime(fecha_fin).date()) &
    (df_ncu['TIME'].dt.hour >= 8) &
    (df_ncu['TIME'].dt.hour <= 20 )
]

# Redondear hacia abajo al múltiplo de 5 minutos
df_filtrado['TIME_5MIN'] = df_filtrado['TIME'].dt.floor('5min')

# Agrupar por fecha + hora + minuto (cada 5 minutos) y calcular promedio
df_promedio_5min = df_filtrado.groupby('TIME_5MIN').mean().reset_index()

df_promedio_5min.info()

# Filtrar solo las filas con hora menor o igual a 19:01
df_promedio_5min = df_promedio_5min[df_promedio_5min['TIME'].dt.time <= pd.to_datetime("19:05").time()]



# Guardar en Excel
excel_path = 'posicion_tracker_salta_sep_FILTRADO.xlsx'

# Eliminamos el timezone para evitar errores en Excel
NCU_copy = df_promedio_5min.copy()
#NCU_copy.index = NCU_copy.index.tz_localize(None)

NCU_copy.to_excel(excel_path, index=True)
print(f"✅ Archivo Excel guardado correctamente en: {excel_path}")
# ===============================================================

# Merge usando TIME_5MIN de df1 como referencia
df_concat = pd.merge(df_promedio_5min, trk_copy, left_on='TIME_5MIN', right_on='TIME', how='left')



print(df_concat.head())

df_concat.info()

import numpy as np
conditions = [
   df_concat['ncu_1/angulo_actual_box_3'] < 90,
   df_concat['ncu_1/angulo_actual_box_3'] >= 90

]

choices = [
   (df_concat['ncu_1/angulo_actual_box_3'] - 90) * -1,  # caso < 90, multiplicar por -1
    90 - df_concat['ncu_1/angulo_actual_box_3'],  # caso > 90

]

df_concat['angulo_control_box_custom'] = np.select(conditions, choices)

# Guardar en Excel
excel_path = 'posicion_tracker_MERGE.xlsx'

# Eliminamos el timezone para evitar errores en Excel
MERGE_NCU= df_concat.copy()
#NCU_copy.index = NCU_copy.index.tz_localize(None)

MERGE_NCU.to_excel(excel_path, index=True)
print(f"✅ Archivo Excel guardado correctamente en: {excel_path}")
# ===============================================================

MERGE_NCU.info()

import matplotlib.pyplot as plt

# Crear la columna DATE si no existe
MERGE_NCU['DATE'] = MERGE_NCU['TIME_5MIN'].dt.date

plt.figure(figsize=(10,6))
for date, MERGE_NCU in MERGE_NCU.groupby('DATE'):
    plt.plot(MERGE_NCU['TIME_5MIN'], MERGE_NCU['angulo_control_box_custom'], label=f'Real {date}')
    plt.plot(MERGE_NCU['TIME_5MIN'], MERGE_NCU['tracker_theta'], '--', label=f'PVlib {date}')

plt.title('Comparación diaria de posiciones del tracker')
plt.xlabel('Hora')
plt.ylabel('Ángulo (°)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import plotly.express as px

# Asegúrate de que DATE sea tipo string o datetime
MERGE_NCU['DATE'] = MERGE_NCU['TIME_5MIN'].dt.date.astype(str)

fig = px.line(
    MERGE_NCU,
    x='TIME_5MIN',
    y=['angulo_control_box_custom','tracker_theta'],
    color='DATE',
    title='Posición Tracker Real vs PVlib por día'
)

fig.update_xaxes(rangeslider_visible=True)
fig.show()

import plotly.express as px

# Filtrar el día que te interesa
dia = '2025-09-30'
df_filtrado = MERGE_NCU[MERGE_NCU['TIME_5MIN'].dt.date.astype(str) == dia]

# Graficar solo ese día
fig = px.line(
    df_filtrado,
    x='TIME_5MIN',
    y=['angulo_control_box_custom', 'tracker_theta'],
    title=f'Posición Tracker Real vs PVlib - {dia}'
)

fig.update_xaxes(rangeslider_visible=True)
fig.show()

MERGE_NCU.info()

import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd

# Asegurar columna DATE
MERGE_NCU['DATE'] = MERGE_NCU['TIME_5MIN'].dt.date

# Obtener lista de fechas únicas de septiembre
fechas = sorted(MERGE_NCU['DATE'].unique())

# Crear subplots: 6 filas x 5 columnas = 30 gráficos
fig = make_subplots(
    rows=6, cols=5,
    shared_xaxes=False,
    shared_yaxes=False,
    subplot_titles=[str(f) for f in fechas]
)

# Loop por cada fecha
row, col = 1, 1
for fecha in fechas:
    df_dia = MERGE_NCU[MERGE_NCU['DATE'] == fecha]

    # Agregar línea teórica
    fig.add_trace(go.Scatter(
        x=df_dia['TIME_5MIN'],
        y=df_dia['tracker_theta'],
        mode='lines',
        name='Teórico PVlib',
        line=dict(color='royalblue', width=1)
    ), row=row, col=col)

    # Agregar puntos reales
    fig.add_trace(go.Scatter(
        x=df_dia['TIME_5MIN'],
        y=df_dia['angulo_control_box_custom'],
        mode='lines',
        name='Real',
        line=dict(color='orange', width=1)
    ), row=row, col=col)

    # Avanzar posición en la grilla
    col += 1
    if col > 5:
        col = 1
        row += 1

# Ajustes visuales
fig.update_layout(
    height=3500, width=2500,  # tamaño tipo hoja A3
    title_text="Posición Tracker Real vs PVlib - Septiembre 2025",
    showlegend=False,
    margin=dict(t=100)
)

fig.show()

import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd

# Asegurar columna DATE
MERGE_NCU['DATE'] = MERGE_NCU['TIME_5MIN'].dt.date

# Seleccionar los días que querés graficar
dias_interes = [
    pd.to_datetime('2025-09-01').date(),
    pd.to_datetime('2025-09-09').date(),
    pd.to_datetime('2025-09-10').date()
]

# Crear subplots (1 fila x 3 columnas)
fig = make_subplots(
    rows=1, cols=3,
    shared_yaxes=False,
    subplot_titles=[str(d) for d in dias_interes]
)

# Loop por cada día
col = 1
for fecha in dias_interes:
    df_dia = MERGE_NCU[MERGE_NCU['DATE'] == fecha]

    # Línea teórica
    fig.add_trace(go.Scatter(
        x=df_dia['TIME_5MIN'],
        y=df_dia['tracker_theta'],
        mode='lines',
        name='Teórico PVlib',
        line=dict(color='royalblue', width=1)
    ), row=1, col=col)

    # Línea real
    fig.add_trace(go.Scatter(
        x=df_dia['TIME_5MIN'],
        y=df_dia['angulo_control_box_custom'],
        mode='lines',
        name='Real',
        line=dict(color='orange', width=1)
    ), row=1, col=col)

    col += 1

# Ajustes visuales
fig.update_layout(
    height=800, width=2400,  # formato apaisado
    title_text="Posición Tracker Real vs PVlib - Días 01, 09 y 10 Septiembre 2025",
    showlegend=True,
    margin=dict(t=100)
)

fig.show()

import pandas as pd

# Asegurarse de que TIME_5MIN es datetime
MERGE_NCU['TIME_5MIN'] = pd.to_datetime(MERGE_NCU['TIME_5MIN'])

# Crear columna DATE
MERGE_NCU['DATE'] = MERGE_NCU['TIME_5MIN'].dt.date

# Días a analizar
dias_interes = [
    pd.to_datetime('2025-09-01').date(),
    pd.to_datetime('2025-09-09').date(),
    pd.to_datetime('2025-09-10').date()
]

# Filtrar solo los días seleccionados
df_filtrado = MERGE_NCU[MERGE_NCU['DATE'].isin(dias_interes)]

# Filtrar entre 10:00 y 17:00
df_filtrado = df_filtrado[
    (df_filtrado['TIME_5MIN'].dt.hour >= 10) &
    (df_filtrado['TIME_5MIN'].dt.hour <= 17)
]

import numpy as np

metricas = []

for fecha in dias_interes:
    df_dia = df_filtrado[df_filtrado['DATE'] == fecha]
    real = df_dia['angulo_control_box_custom']
    teorico = df_dia['tracker_theta']

    mae = np.mean(np.abs(real - teorico))
    rmse = np.sqrt(np.mean((real - teorico)**2))
    desv_prom = np.mean(real - teorico)

    metricas.append({
        'Fecha': fecha,
        'MAE (°)': mae,
        'RMSE (°)': rmse,
        'Desv Prom (°)': desv_prom
    })

df_metricas = pd.DataFrame(metricas)
print(df_metricas)

import plotly.express as px

fig = px.line(
    df_filtrado,
    x='TIME_5MIN',
    y=['angulo_control_box_custom','tracker_theta'],
    color='DATE',
    title='Posición Tracker Real vs PVlib (10:00-17:00) - Días seleccionados'
)

fig.update_xaxes(rangeslider_visible=True)
fig.show()

import pandas as pd
import numpy as np
from sklearn.metrics import r2_score
import plotly.express as px

# Días a analizar
dias_interes = [
    pd.to_datetime('2025-09-01').date(),
    pd.to_datetime('2025-09-09').date(),
    pd.to_datetime('2025-09-10').date()
]

metricas = []

for fecha in dias_interes:
    df_dia = MERGE_NCU[
        (MERGE_NCU['DATE'] == fecha) &
        (MERGE_NCU['TIME_5MIN'].dt.hour >= 10) &
        (MERGE_NCU['TIME_5MIN'].dt.hour <= 17)
    ]

    real = df_dia['angulo_control_box_custom']
    teorico = df_dia['tracker_theta']
    error = real - teorico

    r2 = r2_score(real, teorico)
    corr = real.corr(teorico)
    std_error = np.std(error)

    metricas.append({
        'Fecha': fecha,
        'R2': r2,
        'Correlación': corr,
        'Std Error (°)': std_error
    })

df_metricas = pd.DataFrame(metricas)
print(df_metricas)

# Graficar
fig = px.bar(
    df_metricas.melt(id_vars='Fecha', var_name='Métrica', value_name='Valor'),
    x='Fecha',
    y='Valor',
    color='Métrica',
    barmode='group',
    title='R², Correlación y Desviación Std del Error - Tracker vs PVlib (10-17h)'
)
fig.show()

"""📊 Conclusión general:

✔️ Todos los indicadores (R² > 0.96, correlación > 0.99, error < 5°) muestran que:

El sistema de seguimiento real se comporta de forma muy coherente con el modelo PVlib.

Cualquier diferencia restante (2–5°) puede deberse a:

calibración del sensor de ángulo,

errores mecánicos del tracker,

desfases horarios (por segundos o minutos),

pequeñas variaciones topográficas o de instalación.
"""